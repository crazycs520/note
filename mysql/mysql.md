# install

## on mac

```shell
brew install mysql	
```

config the mysql database

```shell
unset TMPDIR

mysql_install_db --verbose --user=`dbUserName` --basedir="$(brew --prefix mysql)" --datadir=/usr/local/var/mysql --tmpdir=/tmp
```

change root password

```shell
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('crazycs');
```



start the mysql server

```Shell
mysql.server start
```

connect to mysql

```Shell
mysql -u root
```



# SQL

```shell
#显示表列信息
show columns from customers;   # 等于  describe customers;
```



# 基础

## 事务

**事务的ACID**

原子性（atomicity），一致性（consistency），隔离性（isolation） ，持久性（durability）

**SQL四种隔离级别**

1. READ UNCOMMITTED （未提交读）：事务中的修改，即使没有提交，对其他事务也是可见的。实际中很少使用。

2. READ COMMITTED （提交读）: 一个事务从开始到提交前，对其他事务都是不可见的。也叫不可重复读，因为两次执行查询可能会得到不一样的结果。

3. REPEATABLE（可重复读）： 保证同一事务中多次读取同样记录结果是一致的。但是还是无法解决**幻行**问题。幻读是指当某个事务读取某个范围内的记录时，另一个事务又在该范围内插入了新记录，当事务再次读取该范围记录时，会参生幻行( Phantom ROW )。

   * 幻像（Phantom Problem ） 是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果：第二次的SQL语句可能返回之前不存在的行。

   REPEATABLE是mysql的默认隔离级别。

4. SERIALIZABLE （可串行化）: 最高隔离级别，强制所有事务串行执行。它会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。



# mySQL简介

* mysql 是一个单进程多线程架构的数据库
* `mysql --help | grep my.cnf`  查看配置文件存放路径，多个配置文件则以最后读到的配置文件为准。
* mysql组成部分
  * 连接池组件
  * 管理服务和工具组件
  * SQL接口组件
  * 查询分析组件
  * 缓冲组件
  * **插件式存储引擎**
  * 物理文件

## mySQL存储引擎

`show engines` ： 查看MYSQL存储引擎

**InnoDB** ： mysql 5.5.8版本开始是默认引擎

* 支持ACID事务，行锁，外键，全文索引，B+树索引，哈希索引
* 用MVCC多版本并发控制来获得高并发性，一致性非锁定读
* 实现了标准SQL的四种隔离级别，默认是可重复读（repeatable），并用next-key-locking 策略避免幻读
* 提供插入缓存，二次写，自适应哈希，预读（read ahead）
* 用聚集方式存储数据，如果表没有指定主键，则自动为每一行生成一个6字节的ROWID做为主键


**InnoDB存储消耗空间比MyISAM大**

**MyISAM**   :    mysql 5.5.8版本之前是默认引擎

* 不支持事务
* 表锁，全文索引
* 缓存池只缓存索引文件，数据文件缓存由操作系统完成
* MYD文件存放数据，MYI文件存放索引

**NDB**  :  集群引擎

**Memory** 

* 适合存储临时数据临时表
* 默认使用哈希索引
* 表锁，不支持TEXT和BLOB列类型

**Maria**

* 支持缓存数据文件和索引文件
* 行锁
* MVCC
* 支持事务

# InnoDB存储引擎

## 体系架构

### 后台线程

1. Master Thread : 负责将缓冲池的数据异步刷新到磁盘，包括脏页的刷新，合并插入缓存，UNDO页回收。
2. IO Thread :因为InnoDB 使用AIO（Async IO）处理写IO请求，该线程主要负责这些AIO的请求回调。主要有四种IO thread : write , read  ,  insert  buffer  ,   log  io thread ;读写线程数可以设置：`innodb_read_io_threads` 和 `innodb_write_io_threads` 
3. Purge Thread  :  负责回收已使用并分配的undo页。
4. Page Cleaner Thread ：   负责脏页刷新，减轻Master thread 线程的工作量。

### 内存

1. 缓存池：  按照页进行管理，页大小默认为16KB。页的刷新回磁盘通过 Checkpoint  机制控制。大小可以配置：`innodb_buffer_pool_size`
   * 缓存的数据也类型： 索引页，数据页，undo页，插入缓冲（insert buffer），自适应哈希索引，innoDB存储的**锁**信息，数据字典信息。
   * 允许多个缓存池实例，配置参数：`innnodb_buffer_pool_instances`
   * innoDB1.0.X版本开始支持压缩页功能，将原本的16KB页压缩为1KB，2KB，4KB，8KB。压缩页是由  unzip_LRU 列表管理。
2. LRU List ,  Free List   ,   Flush  list
   * LRU   List
     * 缓存池通过LRU（ latest recent used ）算法管理。最频繁使用的在LRU列表前段，反之在尾端。不够用时首先释放尾端的页。
     * Innodb 对LRU List 中加入了 midpoint  位置，新读到的页并不放人首部，而是在midpoint位置，该参数可以配置：`   innodb_old_blocks_pct` ，默认是37，即尾端的37%处。为什么不放在首部？因为某些SQL操作（数据的索引或扫描）会访问很多页甚至全部页面，放在首部会把热点页刷出，印象缓存命中率。如果预估热点数据不止63%,则减小`innodb_old_blocks_pc`
     * `innodb_old_blocks_time`用于表示页读取到midpoint位置后多久后加入LRU的热端。
     * LRU list的old 部分加入到 new部分时，此时发生的操作称为   page made  young , 而因`innodb_old_blocks_time`未能从old移入new部分操作称为 page not made young。
   * Free  List  ： 数据库刚启动时，LRU列表是空的，此时所有的页都存在Free list 中。当需要从缓存池中分页时，首先从Free List 中找空闲页，有就从free list 中删除放入LRU列表，否则根据LRU算法淘汰列表末尾页，将该内存空间分配给新页。
   * Flush List : 脏页列表
     * 在LRU列表中的列表修改后，该页为脏页，把该页存入Flush list （注意：脏页即存在LRU列表中，也存在Flush 列表中）,   然后通过  checkpoint 机制将脏页刷回磁盘。
3. 重做日志缓存（ redo  log  buffer ）
   * 大小配置：`innodb_log_buffer_size` ， 重做日志一般每秒会刷新到日志文件，所以设置多大看每秒的写入量。通常情况下8M满足大部分应用了。
   * 刷新到日志文件情况
     * Master Thread 每秒刷新一次
     * 每个事物提交时刷新一次
     * 当重做日志缓冲池剩余空间小于1/2时
4. 额外内存池
   * innodb通过内存堆 方式管理内存。在对一些数据结构本身进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池进行申请。
   * 例如，分配了缓冲池，但是每个缓冲池中的帧缓冲（frame buffer） 还有缓冲控制对象，这些对象记录了LRU，锁，等待等信息，这个对象的内存也要从额外内存池中申请。
   * 在申请了很大的innodb缓冲池时，也因考虑相应增加这个值。

* `show engine innodb status` 命令，输出有个`Buffer pool hit rate`表示缓存命中率，正常情况下该值大于95%，否则应检查是否由于全表扫描污染了LRU列表。

### CheckPoint技术

​	事务数据库为了避免数据丢失问题，一般普遍采用 Write Ahead Log  策略。当事务提交时，先写重做日志，再修改页。当机器挂了后，可以通过重做日志恢复。

*  checkpoint 解决的问题：
  * 缩短数据库的恢复时间，数据库宕机后，只需要重做checkpoint 之后的日志。
  * 缓冲池不够用时，将脏页刷新回磁盘
  * 重做日志不可用时，刷新脏页，因为数据日志并不是无限大，都是循环使用的。
*  两种checkpoint 
  * Sharp  checkpoint  : 数据库关闭时将脏页刷新回磁盘
  * Fuzzy  checkpoint  ： 数据库运行时的刷新策略，出现如下情况刷新
    * Master thread Checkpoint
    * FLUSH_LRU_LIST checkpoint  : 保证LRU列表中有100多个空闲页可用，在Page Clearner 线程中进行
    * Async/Sync Flush  CheckPoint  ：  在重做日志 不可用情况下，强制刷新回磁盘
    * Dirty Page too much Checkpoint  ：  脏页数太多导致刷新，参数控制：`innodb_max_pages_pct`  ,  默认为75

### Master Thread 工作方式

* Master 线程有最高优先级，内部组成
  * 主循环loop
  * 后台循环（ background loop）
  * 刷新循环（flush  loop ）
  * 暂停循环（  suspend loop ）
* 主循环（loop）两大操作
  * 每秒一次的操作
    * 日志缓存刷新到磁盘（总是），即使事务未提交  ： 所以即使大事务的提交也很快
    * 合并插入缓冲（可能）：判断前一秒的IO次数，如果小于5，则IO压力小，可以执行
    * 刷新至多100个缓存池中的脏页回磁盘（可能） ：判断脏页中的比例`buf_get_modified_ratio_pct`    ,可以配置参数：`innodb_max_dirty_pct` ，超过此值，就执行。
    * 如果当前用户没有活动，切到 background loop （可能）
  * 每10秒一次的操作
  * 刷新100个脏页到磁盘（可能）： 判断过去10秒的IO次数，小于200 ， 就执行。
  * 合并至多5个插入缓存（总是）
  * 刷新日志缓冲回磁盘（总是）
  * 删除无用的100个undo 页（总是）
  * 刷新100 或 10 个脏页回磁盘（总是）
* 后台循环（ background loop） ： 数据库空闲时会切换到此循环
  * 删除无用的undo页（总是）
  * 合并20个插入缓冲（总是）
  * 跳回主循环（总是）

### InnoDB关键特性

1. 插入缓冲（insert buffer）
2. 两次写
3. 自适应哈希索引（adaptive hash index , AHI）
4. 异步IO（AIO）
5. 刷新邻接页

* 插入缓冲

  * Insert buffer 和数据页一样，也是物理页的组成部分
  * 插入聚集索引（primary key） 一般是物理顺序的，非聚集且不唯一的索引插入时，不是物理顺序的
  * 对于非聚集索引的插入或更新操作，不是每次直接插入到索引页，而是先判断插入的非聚集索引页是否在缓存池中，若在，则直接插入，若不在，先放在 insert buffer 中，然后再以一定频率进行insert buffer 和辅助索引页子节点的merge（合并）。
  * insert buffer 的使用必须满足以下条件
    * 索引是辅助索引
    * 索引不唯一

* Change Buffer

  可视为Insert buffer 的升级。InnoDB引擎可以对DML操作----insert ， delete  ,  update  都进行缓冲，分别是：insert buffer  ,  delete buffer  , purge buffer 。这些统称为Change buffer。

  * 适用对象依然是非唯一的辅助索引。

  * 对应于一个update 操作，分为两个过程

    * 将记录标记为删除
    * 真正删除记录

    delete  buffer  对应于标记过程， purge buffer 对应真正删除过程。

  * Change buffer 大小控制参数： `innodb_change_buffer_max_size` ,默认是25，表示最多使用缓冲池的25%空间，最大有效值是50，即50%。

* Insert Buffer 实现

  * **B+树**


* Merge Insert Buffer

  将Insert buffer中的记录合并到正在的辅助索引中。具体发生情况如下

  * 辅助索引页被读到缓存池时
  * Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间时
  * Master Thread



* 两次写（doubleWrite）
  * insert buffer 带来性能上的提升，两次写带来的是数据页可靠性。
  * 机器宕机后通过重写日志恢复的前提是：恢复的那个页没有损坏，如果损坏，此时doubleWrite出场
  * 两次写由两部分组成：
    * 内存中的doubleWrite buffer ， 大小为 2MB
    * 磁盘上共享表空间中的连续128个页，即2个区，大小同为2MB
  * 对脏页刷新时，并不直接写磁盘，而是 memcpy 函数将脏页复制到 的doubleWrite buffer 中，之后  的doubleWrite buffe 再分两次，每次1MB顺序的写入共享表空间的磁盘上，然后调用 fsync 函数同步磁盘，避免 insert buffer 带来的问题。因为 double write页是连续的，所以这个操作开销并不大，完成doublewrite 页的写入后，再将  的doubleWrite buffer中的脏页写到各个表文件中
* 自适应哈希索引（adaptive hash index , AHI）
  * 哈希（hash）时间复杂度O（1） ，而B树查找次数取决于树高，一般3~4层，故要3~4次查询
  * InnoDB会监控对表上各个索引页的查询，如果观察到建立hash 索引可以带来速度提升，则建立hash索引，这称为自适应哈希索引（AHI）。
  * AHI有一个要求：对这个页的访问模式必须是一样的，即查询条件是一样的。即使交替两种访问模式访问一个表，InnoDB也不会对该页构建AHI。
* AIO
  * 不阻塞
  * 进行IOMerge
* 刷新邻接页
  * 即AIO中的IO Merge ，合并IO操作
  * 开启的配置参数：`innodb_flush_neighbors`，对机械硬盘开启，固态硬盘设为0 ， 即关闭。



# 文件

* 参数文件
* 日志文件
* socket 文件
* pid 文件
* MySQL表结构文件
* 存储引擎文件

1. 参数文件

   MySQL启动时读取的配置文件，存放优先级目录查看方式：`mysql --help | grep my.cnf`

   两类参数类型：

   * 动态参数：可以在实例运行时更改
   * 静态参数：实例生命周期内不能更改

2. 日志文件

   * 错误日志（error log）:`show variables like 'log_error'`

   * 慢查询日志（slow query log）: 阈值时间设置：`long_query_time`，默认为10 ，单位秒，记录大于该值得日志。

     * `show variables like 'long_query_time'`
     * `show variables like 'log_slow_queries'
     * 另一个配置参数：`log_queries_not_using_indexes`，记录没有使用索引的SQL语句
       * `show variables like 'log_queries_not_using_indexes`
     * `show variables like 'log_output'` ： 制定慢查询输出格式，默认是FILE，可以设置为TABLE，然后通过数据库 mysql.slow_log 表查询，该表引擎默认是CSV，在大数据量下可以更改为 MyISAM引擎，并在start_time 列上添加索引以提高查询效率。不过得在关闭慢查询的情况下设置：`set GLOBAL slow_query_log=off`  关闭慢查询
     * 参数: `long_query_io` ：将超过该参数指定的逻辑IO次数的SQL语句记入 slow log 中

   * 查询日志（log）

     记录所有对MySQL数据库请求的信息，无论这些请求是否正确执行，默认文件名为 : 主机名.log

   * 二进制文件（binlog）

     * 记录对MySQL数据库执行更改的所有操作。不包括select  和 show。有如下作用：
       * 恢复
       * 复制
       * 审计
     * 该日志默认没有开启，需要手动指定。开启会对性能有影响，但有复制和恢复功能，可以考虑开启。这对 point in time 的恢复 和 复制环境的搭建有帮助。

3. 套接字文件

   套接字文件由参数socket 控制，一般在 /tmp  目录下， 名为mysql.sock

4. pid文件

   mysql实例启动时，会把自己进程PID写入一个文件中，该文件可由参数 `pid_file`控制， 默认位于数据库目录下，  名为   主机名.pid

5. 表结构定义文件

   `.frm`为后缀的文件是记录表结构定义的文件，还用来存放视图。

6. InnoDB存储引擎文件

   * 表空间文件 ：  存放的数据按表空间进行存放。默认配置下会有一个`ibdata1`文件，即该文件。

     * 文件路径配置：`innodb_data_file_path` , 如果没有设置`innodb_file_per_table`， 则将innodb引擎所有表的数据都存在该文件下
     * `innodb_file_per_table` :  每个表一个独立的表空间，名为： 表名.ibd

   * 重做日志文件

     * 每个innodb 引擎至少一个重做日志文件组，每个文件组下至少2个重做日志文件。

       * 默认有 ib_logfile0  和 ib_logfile1

       * `innodb_log_file_size`   :  指定每个重做日志文件的大小，太小会导致频繁的 async checkpint

       * `innodb_log_files_in_group`  :   指定日志文件组中日志文件的数量，默认 2

       * `innodb_mirrored_log_groups`  ：  如果磁盘本身有高可用方案，此选项可不开启

         `innodb_log_group_home_dir`  :     指定日志文件所在路径

     * 重做日志文件与二进制日志文件的差别？

       * 二进制日志记录MySQL数据库有关的记录，包括所有引擎； 重做日志只记录innoDB本身的事务日志。
       * 二进制日志记录的是关于一个事务的具体操作，是逻辑日志；重做日志记录的是关于每个页的更改物理情况。
       * 写入时间不同。二进制日志仅在事务提交前进行提交，即只写磁盘一次；而重做日志在事务进行过程中，会多次写入重做日志中。

     * 重做日志有 redo log buffer 

     * 为保证事务的ACID中的持久性，必须将参数: `innodb_flush_log_at_trx_commit` 设置为1 ， 即当事务提交时，必须保证事务都已经写入重做日志，这样宕机后，可以通过重做日志恢复。


# 表

## 索引组织表

* InnoDB存储引擎中，表都是根据主键顺序组织存放的。这种存储方式的表称为索引组织表。每个表的都有一个主键，如果创建表时没有显示的定义主键，则：
  * 先判断是否有非空的唯一索引，有就设该列为主键。如果有多个非空唯一索引，则选择第一个定义的索引（注意不是第一个定义的列）。
  * 没有InnoDB引擎就自动创建一个6个字节大小的指针。

## InnoDB逻辑存储结构

* 从逻辑存储结构看，所有的数据都被逻辑的存放在一个**表空间**里。表空间由**段（segment ），区（extent）, 页（page ）**组成。页有些文档中也称为块。

1. 表空间
   * `innodb_file_per_table` ： 可以配置为每张表一个独立的表空间，但独立的表空间内只存放数据，索引，插入缓冲Bitmap 页。其他数据（如回滚信息，插入缓冲，索引页，系统事务信息，二次写缓冲）还是存放在原来的共享表空间。
2. 段
   * 表空间由各个段组成，常见的段有：数据段，索引段，回滚段等。
   * InnoDB引擎的表是索引组织表，因此数据即索引，索引即数据。数据段即为 **B+树**的叶子节点。索引段即为**B+树**的非叶子节点。
3. 区
   * 区是由连续页组成的空间。每个区大小为1MB ， 为保证区中页的连续性，InnoDB引擎一次从磁盘申请4~5个区。默认InnoDB引擎页的大小为16KB。即1个区中有64个连续的页。
   * InnoDB1.0.X版本开始有压缩页，每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K， 4K，8K。故每个区对应得页数量为512,256,128。
   * InnoDB1.2.X新增参数`innodb_page_size` 可以设置默认页大小为 4K， 8K，16，但页中数据不压缩，此时区中对应页的数量为256,128。总之，不论页怎么变，区大小总是1MB。
4. 页（块）
   * 默认每个页16KB。InnoDB1.2.X新增参数`innodb_page_size` 可以设置默认页大小为 4K， 8K，16K
   * InnoDB引擎中常见的页类型有
     * 数据页
     * undo页
     * 系统页
     * 事务页
     * 事务数据页
     * 插入缓冲位图页
     * 插入缓冲空闲列表页
     * 未压缩的二进制大对象页
     * 压缩的二进制大对象页
5. 行
   * 数据是按行进行存放的。每个页存放的行记录也有硬性定义：16KB /2~200的行记录，即7992行记录。

## InnoDB行记录格式

* `show table status like 'table_name'\G`  查看某个表的行记录格式。

## 分区表

* mysql 数据库支持的分区类型：
  * RANGE 分区 
  * LIST 分区
  * HASH 分区
  * KEY分区

# 索引与算法

## InnoDB引擎支持的索引

* B+树索引
* 全文索引
* 哈希索引（自适应哈希索引，AHI）

注意：B+树索引并不能找到一个给定键值得具体行。B+树索引能找到数据行所在的页。然后把该页读入内存，再在内存中进行查找要找的数据。

## B+树索引

数据库中，B+树的高度一般在2~4层，故查找某一键值的行记录时最多2到4次IO。

* B+树索引可以分为：
  * 聚集索引
  * 辅助索引，也称非聚集索引

1. 聚集索引

   表中数据按照主键顺序存放。而聚集索引（clustered index）就是按每张表的主键构建的一颗B+树。叶节点中存放的即为**整张表**的行记录数据。也将聚集索引的叶子节点称为数据页。每个数据页（叶子节点）都通过一个双向链表进行链接。

   **SQL语句中应尽量使用聚集索引。**

2. 辅助索引

   * 辅助索引的B+树，叶子节点**并不包含行记录的全部数据**。叶子节点除了包含键值外，每个叶只节点中的索引行中还包含一个**书签**。书签用来告诉innodb 引擎哪里可以找到与索引相对应的行数据。
   * 由于innodb引擎的表是索引组织表，因此辅助索引的**书签**就是相应的行数据和聚集索引键。
   * 通过辅助索引来查找数据时，InnovationDB存储引擎会遍历辅助索引并通过**叶级别的指针**获得指向主键索引的**主键**。然后再通过主键索引找到一个完整的行记录。比如：辅助索引和聚集索引的树高都是3，通过辅助索引查找数据，先遍历辅助索引树进行3次查找找到指定主键，然后对聚集索引树遍历3次，最终找到一个完整的行数据所在的页，再把该页读入内存，在页中找到行数据。这样一共需要6次IO访问。

3. 索引管理

   * 创建与删除
     * `ALTER TABLE `     ： 创建
     * `CREATE INDEX`    ：创建
     * `DROP INDEX`    ： 删除
     * `SHOW INDEX FROM table_name`   : 查看表上的索引

## Cardinality 值

* 不是所有的列都适合添加索引，比如性别，城市，类型等
* 怎么查看索引是否是高选择性的？ 答案是 Cardinality 值，可以通过 `SHOW INDEX FROM table_name`   命令查看结果中的Cardinality 。注意：Cardinality 是一个预估值，并不是准确值，实际中，**Cardinality / n_rows_in_table  的值应尽可能的接近1** ， 如果非常小，则慎重考虑是否有必要创建这个索引。

1. InnoDB对Cardinality的统计
   * 通过采样（sample）来完成，这发生在 	INSERT 和 UPDATE 操作中。

## B+树索引的使用

1. 不同应用中B+树索引的使用

   *  OLTP应用中，查询只从数据库中取一小部分数据，比如根据主键取得用户信息，根据订单号取得订单信息。这种情况下，B+树索引的建立是有意义的。
   * OLAP应用中，一般需要访问表中大量的数据，此时就不要对人名建立索引，因为很少对单个用户进行查询。

2. 联合索引

   * 即对表上的多个列进建立一个索引。
   * 比如建立了  （ a , b ） 两个列建立了索引，那么，  ` **** where a=xx AND b=xx  `可以使用（ a , b ）联合索引，对单个a 列  ` **** where a=xx  `   ` 也可以使用（ a , b ）联合索引；但对b 列查询     `  where b=xx    可以使用（ a , b ）联合索引。

3. 覆盖索引

   * InnoDB支持覆盖索引，即**从辅助索引中就可以得到查询的记录**，而不需要查询聚集索引中的记录。
   * 使用覆盖索引的一个好处是 辅助索引不包含整行记录所有的信息，故其大小远比聚集索引小，因此可以减少大量的IO。比如执行 `SELECT count(*) from table_name` 会主动使用辅助索引。

4. 索引提示

   即显示的告诉优化器使用哪个索引。这种情况一般出现在：

   * 某个SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于 SQL 语句本身。
   * `SELECT * FROM t USE INDEX(a) WHERE a=1 AND b=2`  

5. Multi-Range Read 优化

   * 目的是为了减少磁盘的随机访问，将随机访问转化为较为顺序的数据访问。

6. Index Condition Pushdown  优化

   * 即在MySQL取出索引的同时，判断是否可以进行WHERE条件进行过滤，也就是把WHERE条件放在存储引擎层。这样可以大大减小对记录的索取(  fetch )

## 哈希算法

* InnoDB引擎使用hash算法对字典进行查找，其冲突机制采用 链表的 方式。
* `SHOW ENGINE INNODB STATUS`  可以查看当前自适应哈希索引的使用情况。

# 锁

## InnoDB存储引擎中的锁

1. 锁的类型

   * 两种标准的**行级锁**
     * 共享锁（ S lock）： 允许事务读一行数据
     * 排他锁（ X lock）：允许删除或更新一行数据
   * 意向锁，把锁定对象分为多个层次，InnoDB的意向锁即表级别的锁，支持两种意向锁：
     * 意向共享锁：事务想要获得一张表中某几行中的共享锁
     * 意向排他锁：事务想要获得一张表中某几行中的排他锁
       * 注意：意向锁不会阻塞除全表扫描外的任何请求，故意向锁与行锁是兼容的。

2. 一致性非锁定读

   * 通过多版本控制（multi versioning ）实现，即：如果读取的行正在执行delete或update , 这个读取操作不会因此等待行锁释放，而是去读行的一个**快照数据**。
   * 快照数据是通过undo 段实现，undo用来事务中的回滚数据，因此快照数据本身没有额外开销。此外，读取快照数据是不需要上锁的。
   * 一致性非锁定读是MySQL的默认读取方式。但在不同的事务隔离级别下，读取的方式不同，并不是每个事务隔离级别下都是采用非锁定的一致性读。
   * 为什么是多版本？**数据快照其实是当前行之前的历史版本，每个行可能有多个历史版本，即不止一个快照数据，所以称为多版本技术，由此带来的并发控制，称为多版本并发控制（MVCC）**。
   * 事务隔离级别 READ COMMITTED  和 REPEATABLE READ 下，InnovationDB使用非锁定一致性读，但是读的数据快照版本不同：
     *  READ COMMITTED 读的快照是锁定行的最新的一份快照数据。导致脏读
     *  REPEATABLE READ  读的快照是事务开始时的行数据版本。

3. 一致性锁定读

   在某些情况下，用户需要显示对数据库读取操作加锁保证逻辑一致性：

   InnoDB引擎对于SELECT 语句支持两种一致性的锁定读操作：

   * `SELECT ... FROM UPDATE`   : 读取行记录加一个X锁（排他锁）, 其他事务不能对已锁定的行加上任何操作。对于一致性非锁定读，即使读的行已经被执行了 `SELECT ... FROM UPDATE`   , 也是可以进行读取的。
   * `SELECT ... LOCK IN SHARE MODE` ：加 S 锁

   这两种一致性锁定读必须在一个事务中，当事务被提交，锁也就释放。因此使用这两种语句时，务必加上 `BEGIN , START TRANSACTION 或者 SET AUTOCOMMIT=0`

4. 自增长（aoto-increment）与锁

   * 每个含有自增长值的表都有一个自增长计数器。当对该表进行插入操作时，这个计数器会被初始化，执行`SELECT MAX(auto_inc_col) FROM t FOR UPDATE` 得到计数器的值。插入操作会根据这个计数器的值加1赋予自增长列。这个实现方式称为AUTO-INC Locking 。这种锁是采用一种特殊的表锁机制，为了提高插入性能，锁在完成对自增长值插入的SQL语句后立即释放。

5. 外键和锁

   * 外键主要用于引用完整性的约束检查。在InnoDB中，对于一个外键列，如果没有显示地对这个列加索引，InnoDB会自动对其加一个索引，因为这样可以避免表锁。
   * 对于外键值得插入或跟新，首先需要查询父表中的记录，但对父表的SELECT 操作，不一定采用一致性非锁定读，因为这样会引发数据不一致问题，这时用的 `SELECT ... LOCK IN SHARE MODE` , 即主动对父记录加一个S锁，如果父表已经加了X锁，子表上的操作会阻塞。

## 锁的算法

* InnoDB引擎有三个行锁的算法：
  * Record Lock : 单个行记录上的锁
  * Gap Lock  ：间隙锁，锁定一个范围，但不包含记录本身
  * Next-Key Lock：Gap Lock + Record Lock，锁定一个范围且锁定记录本身。
    * 设计目的是解决Phantom Problem 幻行。
    * **当查询的索引有唯一属性时（比如是主键），则优化降级为 Record Lock**，即只锁定记录本身。
    * 对于辅助索引，则会锁定该索引键值的上一个范围到自己和自己到下一个范围。比如 b 列是辅助索引，值为`1,1,3,6,8` , 当A进行`select * from t where b=3 for update`  时，会用Next-Key Lock锁定范围（1，3] , 用Gap Lock锁定范围（3，6） 。如果不用Gap Lock锁定（3，6），则同时如果另一个用户插入索引b=3的一个记录，这会导致A再次执行同样的查询时返回不同的记录。
* 如果InnoDB引擎表在建立时没有设置任何索引，则InnoDB存储引擎会使用隐式的主键进行锁定。
* 可以通过以下两种方式显示关闭Gap Lock，然后，除了外键约束和唯一性检查依然需要Gap Lock ，其余情况仅仅使用Record Lock。但是，不太建议这么做~
  * 将失误隔离级别设置为 READ COMMITTED
  * 将参数 `innodb_locks_unsafe_for_binlog`  设置为1
* 幻行（Phantom Problem） 问题：a的值为`1,2,5`如A执行`select * from t where a >2 for UPDATE` ，如果不采用Next-Key Lock，则A只锁定a=5这一行，此时B插入了一条a=4的记录会成功。如果用Next-Key Lock，则A锁定的范围是（2，正无穷），此时B的插入不会成功。
* InnoDB的默认隔离级别是REPEATABLE READ ，此时采用Next-Key Lock 的方式加锁，而在READ COMMITTED 隔离级别下，仅仅采用 Record Lock。

## 锁问题

1. 脏读

   * 脏数据与脏页的区别？
     * 脏页是指缓存中已经被修改的页，但也还没有刷新到新的磁盘中。
     * 脏数据是指事务对缓存池中的行记录的修改，并且还没有提交。
     * 脏页的读取，是正常的，因为这是内存与磁盘的异步带造成的，并不影响数据的最终一致性。
     * 脏数据是指事务中未提交的数据，脏读是指一个事务可以读到另一个事务中未提交的数据。如果隔离级别设置为 READ  UNCOMMITTED , 会出现脏读。

2. 不可重复读

   * 是指在一个事务内多次读取同一数据集合，在这个事务还未结束时，另一个事务也访问该同一数据集合，并做了一些DML操作，因此，第一个事务中的两次读数据之间，由于第二个事务的更改，第一个事务两次读到的数据可能不一样。
   * 不可重复读与脏读的区别？
     * 脏读是读到的未提交数据
     * 不可重复读读到的是已提交的数据。
   * InnoDB通过 Next-key Lock 来避免不可重复读的问题。MySQL将 不可重复读的问题定义为 Phantom Problem ， 即幻象问题。

3. 丢失更新

   丢失更新是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据不一致。

   数据库即使在 READ COMMITTED的隔离级别也能阻止丢失更新。但需要注意逻辑意义上的丢失更新，这种情况的发生不是因为数据库导致的，而是用户操作导致，需要留意。

## 阻塞

*  参数设置：`innodb_lock_wait_timeout` 用来控制阻塞等待的时间，默认是50秒。
* `innodb_rollback_on_timeout` 用来设置是否在等待超时时对进行中的事务进行回滚操作，默认是OFF  ，代表不回滚。

## 死锁

* 死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。
* 解决死锁方法
  * 把死锁的等待转为回滚
  * 超时
  * Wait-for-graph (等待图) 来进行死锁检测，它要保存两中信息
    * 锁的信息链表
    * 事务等待链表

## 锁升级

* 是指将当前锁的粒度降低。比如，把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。







 









​                                                                                                  










































# MySQL内参运维

##用户连接线程

* 3中连接方式：命名管道，**套接字**，共享内存。一般都是套接字连接。
* `max_connection` ： 设置以限制最大连接
* 连接线程池：用户连接退出后，服务器并不真正的销毁工作线程，而是将她缓存起来。所以当有新请求到来时，会先判断当前用户连接数是否超过`max_connection`  ，超过则拒绝连接；然后MySQL从线程池缓存中找有无空余线程，没有则新建一个线程。

### MySQL处理请求

当用户请求到达后，

1. 对查询缓存访问。`Query Cache` 中存放着最近一段时间内，出现频率最高的语句和对应的查询结果。判断当前请求语句是否在缓存中，但是，只有在请求语句完全相同，包括空格及大小写一样的情况下才能命中缓存，如果命中缓存则直接把结果返回给用户。
2. 对请求SQL解析

## MySQL表对象缓存

MySQL中有很多类型的系统对象，包括 表， 视图 ， 存储过程，存储函数等。

表对象缓存，是将某个表对象的字典信息（定义内容）从系统表中读取进来，缓存到内存中。

当用户查询某个表数据时，系统首先要先找到这个表。表字典对象缓存是通过`HASH`表来管理，通过表名（包括模式名）来构建HASH键值。

**SHARE 缓存**

`TABLE_SHARE`结构体，唯一对应MySQL中的一个表对象，不区分存储引擎。也是HASH键值对应的Value。

在打开一个表时，这个表首先得在**MySQL系统表**中存储，**系统表**分两个层次，一个层次是**MySQL的.frm 文件**，这是共有的，与存储引擎无关；另一个层次要分不同的存储引擎，不同的存储引擎有自己的系统表。

打开表时，首先从系统表中将这个表的所有信息（包括表名， 模式名，所有的列信息，表的字符集，对应得.frm文件路径，所属的存储引擎，主键等）读入到内存中，通过`TABLE_SHARE`结构体存储，这是表对象缓存的第一层，`TABLE_SHARE`是所有用户共享的一个表对象，所以是静态的，不允许在内存中修改，从系统表中读入缓存直到删除，中间不会做任何修改。

**实例化对象缓存**

但真正在操作中被使用的对象，是`TABLE`结构体，从`TABLE_SHARE`结构体到`TABLE`结构体的构造过程称为实例化。

`TABLE`结构体对象是动态的、被实例化的对象，具体到某一个存储引擎。所以还要构造这个对象有关存储引擎的信息。

因为MySQL是插件式的数据库管理系统，对于表对象管理，MySQL层与引擎层就是这里分开的。`TABLE` 算是它们之间的桥梁。

在实例化后，这个表对象就可以直接与存储引擎进行交互了。在一个操作完成后，这个实例化对象不会被释放，而是缓存起来。缓存到哪里？

每个`TABLE_SHARE`结构体有两个链表—`free_tables` 链表 和 `used_tables` ，free——tables 用来存储未使用的实例化实例，used_tables用来存储正在使用中的实例化实例。

**表缓存管理**

表对象缓存有两部分，一个是 `TABLE_SHARE`缓存，另一个是`TABLE`实例化对象缓存。

MySQL管理表缓存空间大小是通过**计数**来实现的。

 `table_definition_cache`  : `SHARE` 缓存最大**个数**

当表缓存个数超过 `table_definition_cache` 后，会删除一些不常用的`SHARE` 缓存。

对表结构，依赖关系，表定义等信息进行修改后，也会删除这个表的`SHARE` 缓存，同时删除被实例化的表对象缓存。

`table_open_cache` : `SHARE` 缓存的**实例化对象**最大 **个数**。超过这个值后，会删除一些不常用的实例化对象。

从表缓存的2层缓存可以看出，实现插件式存储引擎是有代价的，中间加入了一层SHARE 缓存，真正用到还需要在SHARE 的基础上进行实例化，每个SHARE对象可能有多个实例化对象，造成了一定的浪费和CPU压力。

一个表的SHARE缓存只有一个，但其实例化缓存可能有多个。

**存在的问题**

表缓存的管理是通过计数来管理的，故不能做到很精准，有时候一些大表的出现可能会使得内存不可控，故建议把大表拆分为多个小表。可以把每个结构体占用的内存大小计算出来通过固定的内存空间大小进行控制。

# InnoDB引擎

## InnoDB引擎文件组织

（包括MySQL文件）

**MySQL日志文件**

* slow.log ：慢查询日志文件。配置参数：`log_query_time`，超过改值后就会记录到这个日志文件中。
* error.log ：记录系统启动和运行时的错误，警告信息。配置参数：`log_error`
* general.log ：记录所有在数据库上执行的语句，常用来追踪问题，但会影响性能。在QPS很高的情况下这个文件会非常大。

**三个系统信息数据库**

**information_schema**

它包括访问数据库元数据的方式。元数据—Metadata 是关于数据的数据，如数据库名或表名，列的数据类型，访问权限等。

这个数据库可以用来做一些自动化的处理工作，如 `Percona Toolkit`数据包 的信息来源就是这个数据库。

但是，这个库有缺点，它在每次查找时，都会现场统计相应的信息，这需要将相应的信息加载到内存中，做成内存表。如果表比较多的话，这将会很慢，需要谨慎处理。

**performance_schema**

这个数据库主要用来收集数据库服务器的性能参数。包括：

* 提供进程等待的详细信息，包括锁，互斥变量，文件信息。
* 保存历史事件汇总信息，为判断MySQL性能做出详细的依据
* 添加或删除监控事件点都很容易，可以随意改变MySQL服务器的监控周期

**sys**

是MySQL5.7 首次加入的，通过**视图**的形式把 **information_schema** 和  **performance_schema** 结合起来，查询出更容易理解的结果。前提是这个表依赖**information_schema** ， 使用时也要注意。

**InnoDB存储引擎特点**

支持事务，设计目标主要面向在线事务处理（OLTP）的应用。支持行锁，支持外键，非锁定读。

使用多版本并发控制（MVCC）来获得高并发性能；实现了SQL标准的4种隔离，默认为`REPEATABLE`级别，同时使用`next-key locking`的策略来避免幻读。提供插入缓存（insert buffer），二次写（double write） ，自适应哈希索引（adaptive hash index） , 预读（read ahead）等高性能，高可用功能。

对于表中数据的存储，采用聚集（clustered）的方式，每张表的存储都是按照主键的顺序进行存放，如果没有显式的在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6个字节的ROWID ， 并以此作为主键。

## InnoDB体系结构

<img src="https://raw.githubusercontent.com/crazycs520/images/master/mysql0.png" style="zoom:40%" />

上层部分是MySQL server 和 InnoDB NoSQL的接口。

下面两层是InnoDB的逻辑对象。涉及事务，处理会产生锁，包括表锁和行锁，处理对象包括表，索引，B树。为防止页写入的一致性，需要对页加读写锁。

再下一层是物理层，包括缓存，有日志缓存，数据页缓存。

再下一层是操作系统的IO层。主要包括：

* REDO 日志IO : 当日志缓冲区满了，或者做了checkpoint ，逻辑事务提交等之后，日志必须刷新到磁盘。
* 数据页的IO : 对于 buffer 缓存区的IO，包括两部分，分别是索引数据页 和 回滚页的IO。 

## InnoDB数据字典

用来存储元数据信息的表，属于系统表。

**系统表结构**

InnoDB有四个最基本的系统表，用来存储用户定义的列，表，索引等信息。

1. `SYS_TABLE` : 存储所有以InnoDB为引擎的表，每个记录对应已定义的一个表。
   * NAME : 表名
   * ID 表的ID，8个字节
   * N_COLS：表示这个表的列个数
   * TYPE  ： 表的存储内型，包括记录格式，压缩信息等。
   * SPACE ： 这个表所在的表空间的ID 号。
2. `SYS_COLUMNS` 存储InnoDB中定义的所有表的所有列信息，每一列对应这个表中的列信息。
   * TABLE_ID 表示这个列所属的表ID
   * POS 表示这个列在表中是第几列
   * NAME 列名
   * MTYPE 这个列的主数据类型
   * PRTYTE  这个列的一些精确数据类型，是一个组合值，包括NULL标志，是否有符号数的标志。
   * LEN 这个列的数据长度
   * PREC 这个列的数据精度
3. SYS_INDEXS  存储所有表中的索引信息。每条记录对应一个索引。
   * TABLE_ID
   * ID 索引的ID
   * NAME 索引名
   * N_FIELDS 索引包含的列个数
   * TYPE 索引的类型，如聚簇索引，唯一索引，DICT_UNIVERSAL 、DICT_IBUF（插入缓冲区B+树）
   * SPACE 索引数据所在的表空间的ID
   * PAGE_NO  表示这个索引对应的B+树的根页面
4. SYS_FIELDS 存储索引中定义的索引列
   * INDEX_ID  列所在索引的ID
   * POS 这个列在索引中是第几个索引列
   * COL_NAME 索引列的列名

**ROWID 管理**

Innodb中，用户表 的记录不一定都会有一个RowID列，RowID 列只有在一个表未定义主键时，需要ROWID作为聚簇索引的时候才会被分配给这个表。而ROWID 的管理分配，是全局的，所有表都共享这个ID号。

一般，TABLE_ID , INDEXID , 每次更新一次字典页面的值，就更新字典页，但对于RowID并不如此，因为插入操作远比创建一个表，一个索引要频繁。InnoDB做了优化，每分配一个ROWID,系统只在内存加1，不会修改页，只有当这个值为256的倍数时才写入字典页。那么，如果插入200次，这是系统重启了，ID号岂不是回重复使用？事实是，数据库每次启动时，都将上次写入的ROWID对齐256再加上256，这就不会冲突了。

## InnoDB数据存储结构

**表空间文件组织结构**

新建一个数据库时，InnoDB会初始化一个名为`ibdata1` 的的表空间文件。默认情况下，这个文件会存储所有表的数据，以及系统表：SYS_TABLES  ,  SYS_COLUMNS  ,   SYS_INDEXES  ,  SYS_FIELDS  等。此外，还会存储用来保存数据完整性的回滚数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚的存储位置了。

`InnoDB_file_per_table` ： 可以设置为每一个表都对应一个自己的独立表空间，而不是公共到`ibdata1`文件中。独立的表空间只存储对应表的B+树数据，索引和插入缓冲等信息，其他信息还是存储在默认表空间中。

表空间文件存储的主要是一个表的所有B+树（索引）数据。怎么存储？

B+树（索引）的构成：段，簇，页面。

**段**

 段是一个逻辑概念，用来管理物理文件，是构成索引，回滚段的基本元素。

创建一个B+树（索引）同时会创建两个段，分别是内节点段和叶子段。

* 内节点段用来存储B+树中非页子节（页面）的数据
* 叶子段用来存储B+树中叶子节点的数据。

在索引数据量一直增长的过程中，所有新的存储空间申请，都是从段这个逻辑概念中申请的。

内节点分裂时从内节点段申请新节点；叶子节点分裂时从叶子段中申请。

**簇**

簇在代码中称为`Extent` ， 是构成段的基本元素。一个段由若干个簇组成。

簇是物理上连续分配的一段空间，每一个段至少会有一个簇。创建段时默认会创建一个簇。如果存储数据时，段中的簇不够用时，会从这个段中分配一个新的簇来存放数据，一个段所管理的空间大小是无限的。可以一直扩展，最小的扩展单位是簇。

簇的空间大小是固定的，一般是64个页面。

一个索引由两个段组成，两个段之间的物理位置是没有联系的；每个段由多个簇组成，多个簇之间的物理位置也是没有关系的。

**页面**

页面是簇的组成单位，也是段，数据库文件管理的最小单位，也是文件中空间分配的最小单位。

一个簇默认包涵64个页面，这个页面数称为**簇的大小**。这些页面都归簇管理，在逻辑上（页面号都是从小到大连续的）以及物理上都是连续的。在向表中插入数据时，如果一个页面已经写完，系统会从簇中分配一个新的空闲页面出来使用，如果簇的64个页面都分配完，系统会从当前页面所在段中分配一个新的簇，然后从新簇中分配一个新的页面。

一个页面默认是16K。





























