# install

## on mac

```shell
brew install mysql	
```

config the mysql database

```shell
unset TMPDIR

mysql_install_db --verbose --user=`dbUserName` --basedir="$(brew --prefix mysql)" --datadir=/usr/local/var/mysql --tmpdir=/tmp
```

change root password

```shell
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('crazycs');
```



start the mysql server

```Shell
mysql.server start
```

connect to mysql

```Shell
mysql -u root
```



# SQL

```shell
#显示表列信息
show columns from customers;   # 等于  describe customers;
```



# 基础

## 事务

**事务的ACID**

原子性（atomicity），一致性（consistency），隔离性（isolation） ，持久性（durability）

**SQL四种隔离级别**

1. READ UNCOMMITTED （未提交读）：事务中的修改，即使没有提交，对其他事务也是可见的。实际中很少使用。

2. READ COMMITTED （提交读）: 一个事务从开始到提交前，对其他事务都是不可见的。也叫不可重复读，因为两次执行查询可能会得到不一样的结果。

3. REPEATABLE（可重复读）： 保证同一事务中多次读取同样记录结果是一致的。但是还是无法解决**幻读**问题。幻读是指当某个事务读取某个范围内的记录时，另一个事务又在该范围内插入了新记录，当事务再次读取该范围记录时，会参生幻行( Phantom ROW )。

   REPEATABLE是mysql的默认隔离级别。

4. SERIALIZABLE （可串行化）: 最高隔离级别，强制所有事务串行执行。它会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。



# mySQL简介

* mysql 是一个单进程多线程架构的数据库
* `mysql --help | grep my.cnf`  查看配置文件存放路径，多个配置文件则以最后读到的配置文件为准。
* mysql组成部分
  * 连接池组件
  * 管理服务和工具组件
  * SQL接口组件
  * 查询分析组件
  * 缓冲组件
  * **插件式存储引擎**
  * 物理文件

## mySQL存储引擎

**InnoDB** ： mysql 5.5.8版本开始是默认引擎

* 支持事务，行锁，外键，



# InnoDB存储引擎



# MySQL内参运维

##用户连接线程

* 3中连接方式：命名管道，**套接字**，共享内存。一般都是套接字连接。
* `max_connection` ： 设置以限制最大连接
* 连接线程池：用户连接退出后，服务器并不真正的销毁工作线程，而是将她缓存起来。所以当有新请求到来时，会先判断当前用户连接数是否超过`max_connection`  ，超过则拒绝连接；然后MySQL从线程池缓存中找有无空余线程，没有则新建一个线程。

### MySQL处理请求

当用户请求到达后，

1. 对查询缓存访问。`Query Cache` 中存放着最近一段时间内，出现频率最高的语句和对应的查询结果。判断当前请求语句是否在缓存中，但是，只有在请求语句完全相同，包括空格及大小写一样的情况下才能命中缓存，如果命中缓存则直接把结果返回给用户。
2. 对请求SQL解析

## MySQL表对象缓存

MySQL中有很多类型的系统对象，包括 表， 视图 ， 存储过程，存储函数等。

表对象缓存，是将某个表对象的字典信息（定义内容）从系统表中读取进来，缓存到内存中。

当用户查询某个表数据时，系统首先要先找到这个表。表字典对象缓存是通过`HASH`表来管理，通过表名（包括模式名）来构建HASH键值。

**SHARE 缓存**

`TABLE_SHARE`结构体，唯一对应MySQL中的一个表对象，不区分存储引擎。也是HASH键值对应的Value。

在打开一个表时，这个表首先得在**MySQL系统表**中存储，**系统表**分两个层次，一个层次是**MySQL的.frm 文件**，这是共有的，与存储引擎无关；另一个层次要分不同的存储引擎，不同的存储引擎有自己的系统表。

打开表时，首先从系统表中将这个表的所有信息（包括表名， 模式名，所有的列信息，表的字符集，对应得.frm文件路径，所属的存储引擎，主键等）读入到内存中，通过`TABLE_SHARE`结构体存储，这是表对象缓存的第一层，`TABLE_SHARE`是所有用户共享的一个表对象，所以是静态的，不允许在内存中修改，从系统表中读入缓存直到删除，中间不会做任何修改。

**实例化对象缓存**

但真正在操作中被使用的对象，是`TABLE`结构体，从`TABLE_SHARE`结构体到`TABLE`结构体的构造过程称为实例化。

`TABLE`结构体对象是动态的、被实例化的对象，具体到某一个存储引擎。所以还要构造这个对象有关存储引擎的信息。

因为MySQL是插件式的数据库管理系统，对于表对象管理，MySQL层与引擎层就是这里分开的。`TABLE` 算是它们之间的桥梁。

在实例化后，这个表对象就可以直接与存储引擎进行交互了。在一个操作完成后，这个实例化对象不会被释放，而是缓存起来。缓存到哪里？

每个`TABLE_SHARE`结构体有两个链表—`free_tables` 链表 和 `used_tables` ，free——tables 用来存储未使用的实例化实例，used_tables用来存储正在使用中的实例化实例。

**表缓存管理**

表对象缓存有两部分，一个是 `TABLE_SHARE`缓存，另一个是`TABLE`实例化对象缓存。

MySQL管理表缓存空间大小是通过**计数**来实现的。

 `table_definition_cache`  : `SHARE` 缓存最大**个数**

当表缓存个数超过 `table_definition_cache` 后，会删除一些不常用的`SHARE` 缓存。

对表结构，依赖关系，表定义等信息进行修改后，也会删除这个表的`SHARE` 缓存，同时删除被实例化的表对象缓存。

`table_open_cache` : `SHARE` 缓存的**实例化对象**最大 **个数**。超过这个值后，会删除一些不常用的实例化对象。

从表缓存的2层缓存可以看出，实现插件式存储引擎是有代价的，中间加入了一层SHARE 缓存，真正用到还需要在SHARE 的基础上进行实例化，每个SHARE对象可能有多个实例化对象，造成了一定的浪费和CPU压力。

一个表的SHARE缓存只有一个，但其实例化缓存可能有多个。

**存在的问题**

表缓存的管理是通过计数来管理的，故不能做到很精准，有时候一些大表的出现可能会使得内存不可控，故建议把大表拆分为多个小表。可以把每个结构体占用的内存大小计算出来通过固定的内存空间大小进行控制。

# InnoDB引擎

## InnoDB引擎文件组织

（包括MySQL文件）

**MySQL日志文件**

* slow.log ：慢查询日志文件。配置参数：`log_query_time`，超过改值后就会记录到这个日志文件中。
* error.log ：记录系统启动和运行时的错误，警告信息。配置参数：`log_error`
* general.log ：记录所有在数据库上执行的语句，常用来追踪问题，但会影响性能。在QPS很高的情况下这个文件会非常大。

**三个系统信息数据库**

**information_schema**

它包括访问数据库元数据的方式。元数据—Metadata 是关于数据的数据，如数据库名或表名，列的数据类型，访问权限等。

这个数据库可以用来做一些自动化的处理工作，如 `Percona Toolkit`数据包 的信息来源就是这个数据库。

但是，这个库有缺点，它在每次查找时，都会现场统计相应的信息，这需要将相应的信息加载到内存中，做成内存表。如果表比较多的话，这将会很慢，需要谨慎处理。

**performance_schema**

这个数据库主要用来收集数据库服务器的性能参数。包括：

* 提供进程等待的详细信息，包括锁，互斥变量，文件信息。
* 保存历史事件汇总信息，为判断MySQL性能做出详细的依据
* 添加或删除监控事件点都很容易，可以随意改变MySQL服务器的监控周期

**sys**

是MySQL5.7 首次加入的，通过**视图**的形式把 **information_schema** 和  **performance_schema** 结合起来，查询出更容易理解的结果。前提是这个表依赖**information_schema** ， 使用时也要注意。

**InnoDB存储引擎特点**

支持事务，设计目标主要面向在线事务处理（OLTP）的应用。支持行锁，支持外键，非锁定读。

使用多版本并发控制（MVCC）来获得高并发性能；实现了SQL标准的4种隔离，默认为`REPEATABLE`级别，同时使用`next-key locking`的策略来避免幻读。提供插入缓存（insert buffer），二次写（double write） ，自适应哈希索引（adaptive hash index） , 预读（read ahead）等高性能，高可用功能。

对于表中数据的存储，采用聚集（clustered）的方式，每张表的存储都是按照主键的顺序进行存放，如果没有显式的在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6个字节的ROWID ， 并以此作为主键。

## InnoDB体系结构

<img src="https://raw.githubusercontent.com/crazycs520/images/master/mysql0.png" style="zoom:40%" />

上层部分是MySQL server 和 InnoDB NoSQL的接口。

下面两层是InnoDB的逻辑对象。涉及事务，处理会产生锁，包括表锁和行锁，处理对象包括表，索引，B树。为防止页写入的一致性，需要对页加读写锁。

再下一层是物理层，包括缓存，有日志缓存，数据页缓存。

再下一层是操作系统的IO层。主要包括：

* REDO 日志IO : 当日志缓冲区满了，或者做了checkpoint ，逻辑事务提交等之后，日志必须刷新到磁盘。
* 数据页的IO : 对于 buffer 缓存区的IO，包括两部分，分别是索引数据页 和 回滚页的IO。 

## InnoDB数据字典

用来存储元数据信息的表，属于系统表。

**系统表结构**

InnoDB有四个最基本的系统表，用来存储用户定义的列，表，索引等信息。

1. `SYS_TABLE` : 存储所有以InnoDB为引擎的表，每个记录对应已定义的一个表。
   * NAME : 表名
   * ID 表的ID，8个字节
   * N_COLS：表示这个表的列个数
   * TYPE  ： 表的存储内型，包括记录格式，压缩信息等。
   * SPACE ： 这个表所在的表空间的ID 号。
2. `SYS_COLUMNS` 存储InnoDB中定义的所有表的所有列信息，每一列对应这个表中的列信息。
   * TABLE_ID 表示这个列所属的表ID
   * POS 表示这个列在表中是第几列
   * NAME 列名
   * MTYPE 这个列的主数据类型
   * PRTYTE  这个列的一些精确数据类型，是一个组合值，包括NULL标志，是否有符号数的标志。
   * LEN 这个列的数据长度
   * PREC 这个列的数据精度
3. SYS_INDEXS  存储所有表中的索引信息。每条记录对应一个索引。
   * TABLE_ID
   * ID 索引的ID
   * NAME 索引名
   * N_FIELDS 索引包含的列个数
   * TYPE 索引的类型，如聚簇索引，唯一索引，DICT_UNIVERSAL 、DICT_IBUF（插入缓冲区B+树）
   * SPACE 索引数据所在的表空间的ID
   * PAGE_NO  表示这个索引对应的B+树的根页面
4. SYS_FIELDS 存储索引中定义的索引列
   * INDEX_ID  列所在索引的ID
   * POS 这个列在索引中是第几个索引列
   * COL_NAME 索引列的列名

**ROWID 管理**

Innodb中，用户表 的记录不一定都会有一个RowID列，RowID 列只有在一个表未定义主键时，需要ROWID作为聚簇索引的时候才会被分配给这个表。而ROWID 的管理分配，是全局的，所有表都共享这个ID号。

一般，TABLE_ID , INDEXID , 每次更新一次字典页面的值，就更新字典页，但对于RowID并不如此，因为插入操作远比创建一个表，一个索引要频繁。InnoDB做了优化，每分配一个ROWID,系统只在内存加1，不会修改页，只有当这个值为256的倍数时才写入字典页。那么，如果插入200次，这是系统重启了，ID号岂不是回重复使用？事实是，数据库每次启动时，都将上次写入的ROWID对齐256再加上256，这就不会冲突了。

## InnoDB数据存储结构

**表空间文件组织结构**

新建一个数据库时，InnoDB会初始化一个名为`ibdata1` 的的表空间文件。默认情况下，这个文件会存储所有表的数据，以及系统表：SYS_TABLES  ,  SYS_COLUMNS  ,   SYS_INDEXES  ,  SYS_FIELDS  等。此外，还会存储用来保存数据完整性的回滚数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚的存储位置了。

`InnoDB_file_per_table` ： 可以设置为每一个表都对应一个自己的独立表空间，而不是公共到`ibdata1`文件中。独立的表空间只存储对应表的B+树数据，索引和插入缓冲等信息，其他信息还是存储在默认表空间中。

表空间文件存储的主要是一个表的所有B+树（索引）数据。怎么存储？

B+树（索引）的构成：段，簇，页面。

**段**

 段是一个逻辑概念，用来管理物理文件，是构成索引，回滚段的基本元素。

创建一个B+树（索引）同时会创建两个段，分别是内节点段和叶子段。

* 内节点段用来存储B+树中非页子节（页面）的数据
* 叶子段用来存储B+树中叶子节点的数据。

在索引数据量一直增长的过程中，所有新的存储空间申请，都是从段这个逻辑概念中申请的。

内节点分裂时从内节点段申请新节点；叶子节点分裂时从叶子段中申请。

**簇**

簇在代码中称为`Extent` ， 是构成段的基本元素。一个段由若干个簇组成。

簇是物理上连续分配的一段空间，每一个段至少会有一个簇。创建段时默认会创建一个簇。如果存储数据时，段中的簇不够用时，会从这个段中分配一个新的簇来存放数据，一个段所管理的空间大小是无限的。可以一直扩展，最小的扩展单位是簇。

簇的空间大小是固定的，一般是64个页面。

一个索引由两个段组成，两个段之间的物理位置是没有联系的；每个段由多个簇组成，多个簇之间的物理位置也是没有关系的。

**页面**

页面是簇的组成单位，也是段，数据库文件管理的最小单位，也是文件中空间分配的最小单位。

一个簇默认包涵64个页面，这个页面数称为**簇的大小**。这些页面都归簇管理，在逻辑上（页面号都是从小到大连续的）以及物理上都是连续的。在向表中插入数据时，如果一个页面已经写完，系统会从簇中分配一个新的空闲页面出来使用，如果簇的64个页面都分配完，系统会从当前页面所在段中分配一个新的簇，然后从新簇中分配一个新的页面。

一个页面默认是16K。





























