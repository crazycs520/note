# 计算机网络

1. TCP报头格式

   <img src="https://raw.githubusercontent.com/crazycs520/images/master/tcp.png" style="zoom:30%" />

   * 源、目标端口：16bit , TCP协议通过使用"端口"来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。
   * 顺序号字段：占32比特。用于标识每个报文段，使目的主机可确认已收到指定报文段中的数据，也作用于多个报文段的排序。因为到达的顺序和发送的顺序可能不一致。
   * 确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。目的主机返回确认号，使源主机知道某个或几个报文段已被接收。如果ACK控制位被设置为1，则该字段有效。确认号等于顺序接收到的最后一个报文段的序号加1(建立连接时)或者加上一份数据的大小(数据传输时)，这也是目的主机希望下次接收的报文段的序号值。返回确认号后，计算机认为已接收到小于该确认号的所有数据。
   * 数据偏移（首部长度）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长度。 由于 TCP 报头的长度随 TCP 选项字段内容的不同而变化，因此报头中包含一个指定报头字段的字段。该字段以 32 比特为单位，所以报头长度一定是 32 比特的整数倍，有时需要在报头末尾补 0 。如果报头没有 TCP 选项字段，则报头长度值为 5 ，表示报头一个有 160 比特，即 20 字节。
   * 控制位：6位
     * 紧急 URG：此位置 1，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送。
     * 确认 ACK：仅当 ACK = 1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置 1。
     * 推送 PSH： 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方 TCP 把 PSH 置 1 ，并立即创建一个报文段发送出去，接收方收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付。
     * 复位 RST：用于复位相应的 TCP 连接
     * 同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN = 1 和 ACK = 1。因此，SYN 置 1 就表示这是一个连接请求或连接接受报文。
     * 终止 FIN：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。
   * 窗口（16位）： 此字段用来进行流量控制，这个值是本机期望一次接收的字节数，即发送数据的窗口大小。告诉对方在不等待确认的情况下，可以发来多大的数据。这里表示的最大长度是2^16 - 1 = 65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项。
   * 校验和（16位）：源主机和目的主机根据 TCP 报文段以及伪报头的内容计算校验和。在伪报头中存放着来自 IP 报头以及 TCP 报文段长度信息。
   * 紧急指针（16位）：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据
   * 选项、填充字段  ： 可能包括“窗口扩大因子”、“时间戳”等选项。长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节。
   * 填充用于保证TCP报头为 32bit 的整数倍。
   * 数据（长度可变）

2. UDP报头格式

<img src="https://raw.githubusercontent.com/crazycs520/images/master/udp.png" style="zoom:50%" />

* 源端口（2 字节）：发送方端口号


* 目的端口（2 字节 ）：接收方端口号
* 报文长度（2 字节）：UDP 用户数据报的总长度，以字节为单位。
* 校验和（2 字节）：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。

3. TCP/UDP区别

   * TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
   * UDP(User Datagram Protocol用户数据报协议）是一种无连接的传输层协议，提供简单不可靠信息传送服务。
   * TCP首部开销20字节,UDP首部开销8字节
   * TCP逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
   * TCP协议是面向连接；UDP协议采用无连接
   * TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
   * TCP协议采用滑动窗口协议和流量控制，拥塞控制机制，慢启动，快重传，快恢复，超时重传机制

4. 七层网络模型

   物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

5.  TCP三次握手，四次挥手

   <img src="https://raw.githubusercontent.com/crazycs520/images/master/tcp2.png" style="zoom:40%" />

   <img src="https://raw.githubusercontent.com/crazycs520/images/master/tcp1.png" style="zoom:40%" />

6. HTTP,  TCP,  SOCKET区别

   * TCP连接：建立TCP连接需要3次握手，理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭 连接之前，TCP 连接都将被一直保持下去。断开连接有四次握手
   * HTTP连接： HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接，因此也是“短连接”（除非采用keepalive 长连接）。从建立连接到关闭连接的过程称为“一次连接”。
     * 在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 
     * 在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。
     * `HTTP/2`通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。
   * SOCKET 套接字：它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 
     * 建立SOCKET连接：建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
     * 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 
   * SOCKET连接与TCP连接 ：创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 

7. HTTP请求方法

   * GET ： 请求指定的资源，一般来说`GET`方法应该只用于数据的读取。
   * POST ： 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等
   * HEAD :  方法与`GET`方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应`HEAD`请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。`HEAD`方法常被用于客户端查看服务器的性能。
   * PUT  ：  向指定资源位置上传其最新内容
   * DELETE ：用于请求服务器删除所请求`URI`（统一资源标识符，Uniform Resource Identifier）所标识的资源。
   * CONNECT
   * OPTIONS
   * TRACE

8. HTTP状态码

   - [1xx消息](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx.E6.B6.88.E6.81.AF)——请求已被服务器接收，继续处理
   - [2xx成功](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx.E6.88.90.E5.8A.9F)——请求已成功被服务器接收、理解、并接受
   - [3xx重定向](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx.E9.87.8D.E5.AE.9A.E5.90.91)——需要后续操作才能完成这一请求
   - [4xx请求错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx.E8.AF.B7.E6.B1.82.E9.94.99.E8.AF.AF)——请求含有词法错误或者无法被执行
   - [5xx服务器错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx.E6.9C.8D.E5.8A.A1.E5.99.A8.E9.94.99.E8.AF.AF)——服务器在处理某个正确请求时发生错误

9. SESSION机制、cookie机制

10. 打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。

11. http和https区别，https在请求时额外的过程，https是如何保证数据安全的

12. IP地址子网划分

13. POST和GET区别

14. DNS解析过程

15. 地址解析协议ARP

    以目标IP为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。ARP只适用于IPv4 , IPv6中可用ICMPv6替代ARP。

16. **互联网控制消息协议**（Internet Control Message Protocol，**ICMP**）,它用于[TCP/IP](https://zh.wikipedia.org/wiki/TCP/IP)网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。ICMP的消息大致分为两类：通知出错原因的错误消息，另一类是用于诊断的查询消息。

17. DHCP : Dynamic host configuration Protocal ， 动态主机设置协议，使用UDP协议工作，是一个局域网的网络协议。主要作用有：

    * 用于内部网络或网络服务供应商自动分配[IP](https://zh.wikipedia.org/wiki/IP)地址给用户
    * 用于内部网络管理员作为对所有电脑作中央管理的手段

18. NAT ： Network Address Translator , **网络地址转换**，也叫做网络遮蔽或IP遮蔽。是一种在IP数据包通过[路由器](https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8)或[防火墙](https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99)时重写来源IP地址或目的[IP地址](https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80)的技术。这种技术普遍使用在有多台主机但只通过一个公有IP地址访问[因特网](https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91)的私有网络中。

19. IP隧道: 是指一种在两网络间用[网际协议](https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE)进行通信的通道。

20. 交换机和路由器的区别



# 操作系统

1. 死锁

   所谓**死锁**就是一个进程集合中的多个进程因为竞争资源，而造成的互相等待现象。

   产生死锁的四个必要条件：

   * **互斥条件**：一个资源每次只能被一个进程使用。  
   * **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
   * **不剥夺条件**:进程已获得的资源，在末使用完之前，不能强行剥夺。  
   * **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

   死锁的预防：

   * 破坏互斥条件
   * 破坏不可剥夺条件
   * 破坏请求与保持条件

   死锁的避免：

   * 安全序列：**是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，**这种进程序列{P1，P2，...，Pn}就是安全序列。
   * 银行家算法 ： 是指在分配资源之前先看清楚，资源分配后是否会导致系统死锁。**如果会死锁，则不分配，否则就分配。**

   死锁的解决（InnoDB引擎）：

   * 超时

   * Wait-for-graph 等待图 的方式进行死锁检测，实现需要

     * 锁的信息链表

     * 事务等待链表

       通过上述链表构造出一张图，如果图中有回路，就代表存在死锁。

2. select , poll , epoll 的区别

   * Select: select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。
     * 优点：
       * 可移植性好。
       * 对超时的精度支持单位是微妙。poll是毫秒。
     * 缺点：
       * 单个进程可监视的fd数量有限制。**它由FD_SETSIZE设置，默认值是1024。**
       * 需要维护一个存放大量的fd的数据结构，这使得用户空间和内核空间传递该结构时复制开销大。
       * 对fd是线性扫描，不管哪个Socket是活跃的，都遍历一遍。fd增大后，IO效率较低。
   * poll : 
     * 优点
       * 没有最大连接数限制，原因是它是基于链表来存储的。
       * poll() 不要求开发者计算最大文件描述符加1的大小。
       * poll() 在应付大数目的文件描述符的时候相比于select速度更快 
     * 缺点
       * 大量的fd的数据结构，使得用户空间和内核空间传递该结构时复制开销大。
       * select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`。事实上，`同时连接的大量客户端在一时刻可能只有很少的处于就绪状态`，因此随着监视的描述符数量的增长，其效率也会线性下降。
   * epoll
     * epoll是在Linux 2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
     * epoll在底层实现了自己的高速缓存区，并且建立了一个红黑树用于存放socket，另外维护了一个链表用来存放准备就绪的事件。
     * 特点：epoll支持条件触发和边缘触发。
       * 对于一个读操作的文件描述符，如果是条件触发，只要文件描述符可以读了，就会收到通知，是“可读”这个条件触发了通知。如果是边沿触发，当数据可读时，会收到通知，而且通知有且只有一次，是“有数据”这个变化本身触发了通知。
     * 优点
       * 支持一个进程打开大量数目的fd
       * IO效率不随fd数量增加而线性下降，只与活跃的连接有关，而与连接总数无关，
       * 使用mmap（存储映射）加速内核与用户空间的消息传递。

3. 高级文件IO

   * 分散/聚集IO
   * epoll
   * 内存映射
   * 文件提示
   * 异步IO.

4. 高性能IO模型

   * 同步阻塞IO

   * 同步非阻塞IO

   * IO多路复用

   * 异步IO

     **同步和异步**的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

     **阻塞和非阻塞**的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。

5. Linux支持的进程间的通信机制

   管道，命名管道，信号量，消息队列，共享内存，快速用户空间互斥锁。

6. 进程，线程，协程，*goroutine*

   * 进程：指正在运行的程序，进程包括二进制镜像，加载到内存中，还包括虚拟内存，内核资源，一个或多个线程。进程是系统进行资源分配和调度的一个独立单位。进程和进程之间是的资源都是相互隔离的。
   * 线程是进程内的活动单元。每个线程包含自己的虚拟存储器，包括栈，进程状态和寄存器，以及指令指针。在单线程中，进程即线程。在多线程中，虚拟内存与进程是关联的，所有进程内的所有线程会共享相同的内存地址空间。线程CPU调度的基本单位。
   * 协程通过在线程中实现调度，避免陷入内核级别的上下文切换造成性能损失。协程的调度是由用户控制。
   * *goroutine* 是golang自己实现协程并称为*goroutine* ， 由Goruntime调度。

7. 僵尸进程

   如果一个进程已经终止，但是父进程不知道其状态，该进程称为僵尸进程。Linux中的init进程会等待所有子进程结束，确保子进程永远不会进入僵死状态。如果父进程在子进程之前结束，那么内核会遍历它所有的子进程并把它们的父进程设为 init进程。








# 数据结构

1. hash 散列函数
   * 除余法     hash( key ) = key % m   ,一般m取素数
     * 不足/特点：不动点：hash(0) = 0 ，违反hash的等概率性
       * 零阶均匀：相邻关键吗散列地址也相邻
   * MAD法：multiply - add - divide
     * 取m 为素数，a > 0 , b > 0, a%m !=0  : hash( key ) = ( ( a * key ) +b ) % m 
   * 数字分析：
     * 抽取key中的某几位，如取十进制数的所有的奇数位或偶数位作为key
   * 平方取中 ： hash( 123 ) = 512  ；// 123^2 = 15129 , 取中间三位
     * 保留居中：平方运算后，中间部分由更多的元素位决定。均匀性更好。
   * 折叠法： hash( 123456789  ) = 123 + 456+789 = 1368  ;// 自左向右
     * hash( 123456789 ) = 123+654+789 = 1566 ;  //往复折叠
   * 位异或法  ： hash( 110011011) = 110 ^ 011^ 011 ;// 自左向右
     - hash( 110011011 ) = 110 ^ 110 ^ 011 ;  //往复折叠
   * 伪随机数法 ：这依赖于伪随机数的实现，
2. 解决 hash 冲突
   * 多槽位法： 每个桶有多个槽位，只要槽位不多，依然可以有 O(1) 的效率，但槽位数量的选择：选多了空间效率降低，少了不够
   * 链表法 ： 每个桶保存一个链表的头指针。缺点：链表每次需要申请额外的空间，节点空间未必连续分布，系统缓存几乎失效。
   * 开放定址 ： 每个桶事先约定备用若干备用桶，这样散列表在地址上的空间是连续的，能更好的利用缓存。备用桶之间采用优先级，每次查找沿着查找链逐次转入下个桶。查找链如何约定？
     * 线性试探，一旦冲突，则试探后面紧邻的桶： 查找连具有局部性。
       * 优点：可充分利用系统缓存。缺点：冲突增多，以往的冲突导致后续更多的冲突
       * 惰性删除：直接删除，回收空桶会导致查找链被切断，后续词条会丢失。故惰性删除是仅做标记。而不做真的删除。
     * 平方试探：拉开间距~，每次试探的位置以平方叠加，1^2 , 2^2 , 3^2 ….. ；
       * 优缺点和线性互补，优点，不会因为第一个冲突导致冲突增多；缺点：不能充分利用系统缓存，但还是能用，如1K的页面缓存，如果每个桶为4byte , 则一页有256个桶，即 16^2 。故只有连续冲突16次后才会增加一次IO.
       * 另一个缺点：还有空桶，但试探不到。如果桶数取素数，会有一半（下整）的桶是空的。
     * 双向平方试探 ： +1^2 , -1^2, +2^2 , -2^2……. ，对桶的素数取值有要求，有的很好，有的很糟糕。取 m=4K+3 个桶最好。证明用双平方定理。
3. ​



